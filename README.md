# Сортировка выбором
## Алгоритм сортировки
* находим номер минимального или максимального значения в текущем списке
* производим обмен этого значения со значением первой неотсортированной позиции (обмен не нужен, если минимальный/максимальный элемент уже находится на данной позиции)
* теперь сортируем оставшийся список, исключив из рассмотрения уже отсортированные элементы

## Сортировка выбором :: Selection sort

![SelectionSort](https://user-images.githubusercontent.com/40485432/138320601-43995e73-5a06-4a72-9522-45c8218a1504.gif)

Просто и незатейливо — проходим по массиву в поисках максимального элемента. Найденный максимум меняем местами с последним элементом. Неотсортированная часть массива уменьшилась на один элемент (не включает последний элемент, куда мы переставили найденный максимум). К этой неотсортированной части применяем те же действия — находим максимум и ставим его на последнее место в неотсортированной части массива. И так продолжаем до тех пор, пока неотсортированная часть массива не уменьшится до одного элемента.

Сортировка простым выбором представляет из себя грубый двойной перебор. Можно ли её улучшить? Разберём несколько модификаций.

## Двухсторонняя сортировка выбором :: Double selection sort

![DoubleSelectionSort](https://user-images.githubusercontent.com/40485432/138320623-b37b37ea-9b64-4eb8-ab3e-d3e81add37ba.gif)

Похожая идея используется в шейкерной сортировке, которая является вариантом пузырьковой сортировки. Проходя по неотсортированной части массива, мы кроме максимума также попутно находим и минимум. Минимум ставим на первое место, максимум на последнее. Таким образом, неотсортированная часть при каждой итерации уменьшается сразу на два элемента.

На первый взгляд кажется, что это ускоряет алгоритм в 2 раза — после каждого прохода неотсортированный подмассив уменьшается не с одной, а сразу с двух сторон. Но при этом в 2 раза увеличилось количество сравнений, а число свопов осталось неизменным. Двойной выбор лишь незначительно увеличивает скорость алгоритма, а на некоторых языках даже почему-то работает медленнее.

## Код программы на Delphi
```
program SelectionSort;

{$APPTYPE CONSOLE}
{$R *.res}

uses
  System.SysUtils;

const
  N = 10;

type
  mas = array [1 .. N] of integer;

var
  A: mas;
  i, j, min, tmp: integer;

begin
  writeln('Enter 10 values: ');
  for i := 1 to N do
  begin
    write('Element №', i, ': ');
    readln(A[i]);
  end;

  for i := 1 to N - 1 do
  begin
    min := i;

    for j := i + 1 to N do
      if A[j] < A[min] then
        min := j;

    tmp := A[i];
    A[i] := A[min];
    A[min] := tmp;
  end;

  for i := 1 to N do
  begin
    writeln('Element № ', i, ' Value: ', A[i]);
  end;

  readln;

end.
```
## Блок-схема
<p align="center">
  <img src="https://user-images.githubusercontent.com/40485432/138334759-24c493ac-e255-4ccc-81a8-5511ca6538f9.png" />
</p>
